-- GENERATED by C->Haskell Compiler, version 0.22.1 Snowbounder, 31 Oct 2014 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}
{-# LANGUAGE ForeignFunctionInterface #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE InstanceSigs #-}










{-# LINE 15 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


module System.Hardware.Mraa.Mraa (
  MRAA_RESULT(..),

  mraaInit,
  mraaDeinit,
  mraaPinModeTest,
  mraaAdcRawBits,
  mraaAdcSupportedBits,
  mraaSetLogLevel,
  mraaGetPlatformName,
  mraaSetPriority,
  mraaGetVersion,
  mraaResultPrint,
  mraaGetPlatformType,
  mraaGetPinCount,
  mraaGetPinName,

  mraaI2cInit,
  mraaI2cInitRaw,
  mraaI2cFrequency,
  mraaI2CRead,
  mraaI2cReadByte,
  mraaI2cReadByteData,
  mraaI2cReadWordData,
  mraaI2CReadBytesData,
  mraaI2cWrite,
  mraaI2cWriteByte,
  mraaI2cWriteByteData,
  mraaI2cWriteWordData,
  mraaI2cAddress,
  mraaI2cStop,

  mraaSpiInit,
  mraaSpiInitRaw,
  mraaSpiMode, MRAA_SPI_MODE(..),
  mraaSpiFrequency,
  mraaSpiWrite,
  mraaSpiWriteWord,
  mraaSpiWriteBuf,
  mraaSpiWriteBufWord,
  mraaSpiTransferBuf,
  mraaSpiTransferBufWord,
  mraaSpiLsbmode,
  mraaSpiBitPerWord,
  mraaSpiStop,

  mraaGpioInit,
  mraaGpioInitRaw,
  mraaGpioEdgeMode, MRAA_GPIO_EDGE(..),
  mraaGpioMode, MRAA_GPIO_MODE(..),
  mraaGpioDir, MRAA_GPIO_DIR(..),
  mraaGpioClose,
  mraaGpioRead,
  mraaGpioWrite,
  mraaGpioOwner,
  mraaGpioUseMmapped,
  mraaGpioGetPin,
  mraaGpioGetPinRaw,

  UARTHandlePtr,
  mraaUartInit,
  mraaUartInitRaw,
  mraaUartFlush,
  mraaUartSetBaudrate,
  mraaUartSetMode, MRAA_UART_PARITY(..),
  mraaUartSetFlowcontrol,
  mraaUartSetTimeout,
  mraaUartGetDevPath,
  mraaUartStop,
  mraaUartRead,
  mraaUartWrite,
  mraaUartDataAvailable,

  ) where

import Foreign.Ptr
import Foreign.ForeignPtr
import Foreign.C
import Foreign.Marshal
import Foreign.Storable
import System.IO.Unsafe
--import Data.Functor
--import Control.Applicative
import Control.Monad
import Data.Word
--import System.Posix.IOCtl as I

--type U08 = {#type uint8_t#}
--type U16 = {#type uint16_t#}
--type U32 = {#type uint32_t#}
--type U64 = {#type uint64_t#}
--type S08 = {#type int8_t#}
--type S16 = {#type int16_t#}
--type S32 = {#type int32_t#}
--type S64 = {#type int64_t#}
--type C08 = {#type __u8#}

allocateU32 :: (Ptr CUChar -> IO b) -> IO b
allocateU32 = allocaArray 32
peekU32 :: Ptr CUChar -> IO [CUChar]
peekU32 = peekArray 32

allocate32 :: (Ptr CChar -> IO b) -> IO b
allocate32 = allocaArray 32
peek32 :: Ptr CChar -> IO [CChar]
peek32 = peekArray 32

allocateU32s :: (Ptr CUShort -> IO b) -> IO b
allocateU32s = allocaArray 32
peekU32s :: Ptr CUShort -> IO [CUShort]
peekU32s = peekArray 32

-- This one uses the array, so the unsafe call better not delete it
withUCharArray :: (Storable a, Integral a) => [a] -> (Ptr CUChar -> IO b) -> IO b
withUCharArray = withArray . liftM fromIntegral
withCharArray :: (Storable a, Integral a) => [a] -> (Ptr CChar -> IO b) -> IO b
withCharArray = withArray . liftM fromIntegral

-- This one uses the array, so the unsafe call better not delete it
withUShortArray :: (Storable a, Integral a) => [a] -> (Ptr CUShort -> IO b) -> IO b
withUShortArray = withArray . liftM fromIntegral

data MRAA_PLATFORM = MraaIntelGalileoGen1
                   | MraaIntelGalileoGen2
                   | MraaIntelEdisonFabC
                   | MraaIntelDe3815
                   | MraaIntelMinnoboardMax
                   | MraaRasberryPi
                   | MraaBeaglebone
                   | MraaBananna
                   | MraaUnknownPlatform
  deriving (Eq,Ord,Show)
instance Enum MRAA_PLATFORM where
  succ MraaIntelGalileoGen1 = MraaIntelGalileoGen2
  succ MraaIntelGalileoGen2 = MraaIntelEdisonFabC
  succ MraaIntelEdisonFabC = MraaIntelDe3815
  succ MraaIntelDe3815 = MraaIntelMinnoboardMax
  succ MraaIntelMinnoboardMax = MraaRasberryPi
  succ MraaRasberryPi = MraaBeaglebone
  succ MraaBeaglebone = MraaBananna
  succ MraaBananna = MraaUnknownPlatform
  succ MraaUnknownPlatform = error "MRAA_PLATFORM.succ: MraaUnknownPlatform has no successor"

  pred MraaIntelGalileoGen2 = MraaIntelGalileoGen1
  pred MraaIntelEdisonFabC = MraaIntelGalileoGen2
  pred MraaIntelDe3815 = MraaIntelEdisonFabC
  pred MraaIntelMinnoboardMax = MraaIntelDe3815
  pred MraaRasberryPi = MraaIntelMinnoboardMax
  pred MraaBeaglebone = MraaRasberryPi
  pred MraaBananna = MraaBeaglebone
  pred MraaUnknownPlatform = MraaBananna
  pred MraaIntelGalileoGen1 = error "MRAA_PLATFORM.pred: MraaIntelGalileoGen1 has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from MraaUnknownPlatform

  fromEnum MraaIntelGalileoGen1 = 0
  fromEnum MraaIntelGalileoGen2 = 1
  fromEnum MraaIntelEdisonFabC = 2
  fromEnum MraaIntelDe3815 = 3
  fromEnum MraaIntelMinnoboardMax = 4
  fromEnum MraaRasberryPi = 5
  fromEnum MraaBeaglebone = 6
  fromEnum MraaBananna = 7
  fromEnum MraaUnknownPlatform = 99

  toEnum 0 = MraaIntelGalileoGen1
  toEnum 1 = MraaIntelGalileoGen2
  toEnum 2 = MraaIntelEdisonFabC
  toEnum 3 = MraaIntelDe3815
  toEnum 4 = MraaIntelMinnoboardMax
  toEnum 5 = MraaRasberryPi
  toEnum 6 = MraaBeaglebone
  toEnum 7 = MraaBananna
  toEnum 99 = MraaUnknownPlatform
  toEnum unmatched = error ("MRAA_PLATFORM.toEnum: Cannot match " ++ show unmatched)

{-# LINE 149 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


data MRAA_RESULT = MraaSuccess
                 | MraaErrorFeatureNotImplemented
                 | MraaErrorFeatureNotSupported
                 | MraaErrorInvalidVerbosityLevel
                 | MraaErrorInvalidParameter
                 | MraaErrorInvalidHandle
                 | MraaErrorNoResources
                 | MraaErrorInvalidResource
                 | MraaErrorInvalidQueueType
                 | MraaErrorNoDataAvailable
                 | MraaErrorInvalidPlatform
                 | MraaErrorPlatformNotInitialized
                 | MraaErrorPlatformAlreadyInitialized
                 | MraaErrorUnspecified
  deriving (Eq,Ord,Show)
instance Enum MRAA_RESULT where
  succ MraaSuccess = MraaErrorFeatureNotImplemented
  succ MraaErrorFeatureNotImplemented = MraaErrorFeatureNotSupported
  succ MraaErrorFeatureNotSupported = MraaErrorInvalidVerbosityLevel
  succ MraaErrorInvalidVerbosityLevel = MraaErrorInvalidParameter
  succ MraaErrorInvalidParameter = MraaErrorInvalidHandle
  succ MraaErrorInvalidHandle = MraaErrorNoResources
  succ MraaErrorNoResources = MraaErrorInvalidResource
  succ MraaErrorInvalidResource = MraaErrorInvalidQueueType
  succ MraaErrorInvalidQueueType = MraaErrorNoDataAvailable
  succ MraaErrorNoDataAvailable = MraaErrorInvalidPlatform
  succ MraaErrorInvalidPlatform = MraaErrorPlatformNotInitialized
  succ MraaErrorPlatformNotInitialized = MraaErrorPlatformAlreadyInitialized
  succ MraaErrorPlatformAlreadyInitialized = MraaErrorUnspecified
  succ MraaErrorUnspecified = error "MRAA_RESULT.succ: MraaErrorUnspecified has no successor"

  pred MraaErrorFeatureNotImplemented = MraaSuccess
  pred MraaErrorFeatureNotSupported = MraaErrorFeatureNotImplemented
  pred MraaErrorInvalidVerbosityLevel = MraaErrorFeatureNotSupported
  pred MraaErrorInvalidParameter = MraaErrorInvalidVerbosityLevel
  pred MraaErrorInvalidHandle = MraaErrorInvalidParameter
  pred MraaErrorNoResources = MraaErrorInvalidHandle
  pred MraaErrorInvalidResource = MraaErrorNoResources
  pred MraaErrorInvalidQueueType = MraaErrorInvalidResource
  pred MraaErrorNoDataAvailable = MraaErrorInvalidQueueType
  pred MraaErrorInvalidPlatform = MraaErrorNoDataAvailable
  pred MraaErrorPlatformNotInitialized = MraaErrorInvalidPlatform
  pred MraaErrorPlatformAlreadyInitialized = MraaErrorPlatformNotInitialized
  pred MraaErrorUnspecified = MraaErrorPlatformAlreadyInitialized
  pred MraaSuccess = error "MRAA_RESULT.pred: MraaSuccess has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from MraaErrorUnspecified

  fromEnum MraaSuccess = 0
  fromEnum MraaErrorFeatureNotImplemented = 1
  fromEnum MraaErrorFeatureNotSupported = 2
  fromEnum MraaErrorInvalidVerbosityLevel = 3
  fromEnum MraaErrorInvalidParameter = 4
  fromEnum MraaErrorInvalidHandle = 5
  fromEnum MraaErrorNoResources = 6
  fromEnum MraaErrorInvalidResource = 7
  fromEnum MraaErrorInvalidQueueType = 8
  fromEnum MraaErrorNoDataAvailable = 9
  fromEnum MraaErrorInvalidPlatform = 10
  fromEnum MraaErrorPlatformNotInitialized = 11
  fromEnum MraaErrorPlatformAlreadyInitialized = 12
  fromEnum MraaErrorUnspecified = 99

  toEnum 0 = MraaSuccess
  toEnum 1 = MraaErrorFeatureNotImplemented
  toEnum 2 = MraaErrorFeatureNotSupported
  toEnum 3 = MraaErrorInvalidVerbosityLevel
  toEnum 4 = MraaErrorInvalidParameter
  toEnum 5 = MraaErrorInvalidHandle
  toEnum 6 = MraaErrorNoResources
  toEnum 7 = MraaErrorInvalidResource
  toEnum 8 = MraaErrorInvalidQueueType
  toEnum 9 = MraaErrorNoDataAvailable
  toEnum 10 = MraaErrorInvalidPlatform
  toEnum 11 = MraaErrorPlatformNotInitialized
  toEnum 12 = MraaErrorPlatformAlreadyInitialized
  toEnum 99 = MraaErrorUnspecified
  toEnum unmatched = error ("MRAA_RESULT.toEnum: Cannot match " ++ show unmatched)

{-# LINE 166 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


data MRAA_PINMODES = MraaPinValid
                   | MraaPinGpio
                   | MraaPinPwm
                   | MraaPinFastGpio
                   | MraaPinSpi
                   | MraaPinI2c
                   | MraaPinAio
                   | MraaPinUart
  deriving (Eq,Ord,Show)
instance Enum MRAA_PINMODES where
  succ MraaPinValid = MraaPinGpio
  succ MraaPinGpio = MraaPinPwm
  succ MraaPinPwm = MraaPinFastGpio
  succ MraaPinFastGpio = MraaPinSpi
  succ MraaPinSpi = MraaPinI2c
  succ MraaPinI2c = MraaPinAio
  succ MraaPinAio = MraaPinUart
  succ MraaPinUart = error "MRAA_PINMODES.succ: MraaPinUart has no successor"

  pred MraaPinGpio = MraaPinValid
  pred MraaPinPwm = MraaPinGpio
  pred MraaPinFastGpio = MraaPinPwm
  pred MraaPinSpi = MraaPinFastGpio
  pred MraaPinI2c = MraaPinSpi
  pred MraaPinAio = MraaPinI2c
  pred MraaPinUart = MraaPinAio
  pred MraaPinValid = error "MRAA_PINMODES.pred: MraaPinValid has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from MraaPinUart

  fromEnum MraaPinValid = 0
  fromEnum MraaPinGpio = 1
  fromEnum MraaPinPwm = 2
  fromEnum MraaPinFastGpio = 3
  fromEnum MraaPinSpi = 4
  fromEnum MraaPinI2c = 5
  fromEnum MraaPinAio = 6
  fromEnum MraaPinUart = 7

  toEnum 0 = MraaPinValid
  toEnum 1 = MraaPinGpio
  toEnum 2 = MraaPinPwm
  toEnum 3 = MraaPinFastGpio
  toEnum 4 = MraaPinSpi
  toEnum 5 = MraaPinI2c
  toEnum 6 = MraaPinAio
  toEnum 7 = MraaPinUart
  toEnum unmatched = error ("MRAA_PINMODES.toEnum: Cannot match " ++ show unmatched)

{-# LINE 177 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


data MRAA_I2C_MODE = MraaI2cStd
                   | MraaI2cFast
                   | MraaI2cHigh
  deriving (Eq,Ord,Show)
instance Enum MRAA_I2C_MODE where
  succ MraaI2cStd = MraaI2cFast
  succ MraaI2cFast = MraaI2cHigh
  succ MraaI2cHigh = error "MRAA_I2C_MODE.succ: MraaI2cHigh has no successor"

  pred MraaI2cFast = MraaI2cStd
  pred MraaI2cHigh = MraaI2cFast
  pred MraaI2cStd = error "MRAA_I2C_MODE.pred: MraaI2cStd has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from MraaI2cHigh

  fromEnum MraaI2cStd = 0
  fromEnum MraaI2cFast = 1
  fromEnum MraaI2cHigh = 2

  toEnum 0 = MraaI2cStd
  toEnum 1 = MraaI2cFast
  toEnum 2 = MraaI2cHigh
  toEnum unmatched = error ("MRAA_I2C_MODE.toEnum: Cannot match " ++ show unmatched)

{-# LINE 183 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


data MRAA_UART_PARITY = MraaUartParityNone
                      | MraaUartParityEven
                      | MraaUartParityOdd
                      | MraaUartParityMark
                      | MraaUartParitySpace
  deriving (Eq,Ord,Show)
instance Enum MRAA_UART_PARITY where
  succ MraaUartParityNone = MraaUartParityEven
  succ MraaUartParityEven = MraaUartParityOdd
  succ MraaUartParityOdd = MraaUartParityMark
  succ MraaUartParityMark = MraaUartParitySpace
  succ MraaUartParitySpace = error "MRAA_UART_PARITY.succ: MraaUartParitySpace has no successor"

  pred MraaUartParityEven = MraaUartParityNone
  pred MraaUartParityOdd = MraaUartParityEven
  pred MraaUartParityMark = MraaUartParityOdd
  pred MraaUartParitySpace = MraaUartParityMark
  pred MraaUartParityNone = error "MRAA_UART_PARITY.pred: MraaUartParityNone has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from MraaUartParitySpace

  fromEnum MraaUartParityNone = 0
  fromEnum MraaUartParityEven = 1
  fromEnum MraaUartParityOdd = 2
  fromEnum MraaUartParityMark = 3
  fromEnum MraaUartParitySpace = 4

  toEnum 0 = MraaUartParityNone
  toEnum 1 = MraaUartParityEven
  toEnum 2 = MraaUartParityOdd
  toEnum 3 = MraaUartParityMark
  toEnum 4 = MraaUartParitySpace
  toEnum unmatched = error ("MRAA_UART_PARITY.toEnum: Cannot match " ++ show unmatched)

{-# LINE 191 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaInit :: IO ((MRAA_RESULT))
mraaInit =
  mraaInit'_ >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 194 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaDeinit :: IO ()
mraaDeinit =
  mraaDeinit'_ >>
  return ()

{-# LINE 197 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


-- Need bool
mraaPinModeTest :: (CInt) -> (MRAA_PINMODES) -> IO ((CUInt))
mraaPinModeTest a1 a2 =
  let {a1' = fromIntegral a1} in 
  let {a2' = (fromIntegral . fromEnum) a2} in 
  mraaPinModeTest'_ a1' a2' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 201 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaAdcRawBits :: IO ((CUInt))
mraaAdcRawBits =
  mraaAdcRawBits'_ >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 204 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaAdcSupportedBits :: IO ((CUInt))
mraaAdcSupportedBits =
  mraaAdcSupportedBits'_ >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 207 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaSetLogLevel :: (CInt) -> IO ((MRAA_RESULT))
mraaSetLogLevel a1 =
  let {a1' = fromIntegral a1} in 
  mraaSetLogLevel'_ a1' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 210 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGetPlatformName :: IO ((String))
mraaGetPlatformName =
  mraaGetPlatformName'_ >>= \res ->
  peekCString res >>= \res' ->
  return (res')

{-# LINE 213 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaSetPriority :: (CUInt) -> IO ((CInt))
mraaSetPriority a1 =
  let {a1' = fromIntegral a1} in 
  mraaSetPriority'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 216 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGetVersion :: IO ((String))
mraaGetVersion =
  mraaGetVersion'_ >>= \res ->
  peekCString res >>= \res' ->
  return (res')

{-# LINE 219 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaResultPrint :: (MRAA_RESULT) -> IO ()
mraaResultPrint a1 =
  let {a1' = (fromIntegral . fromEnum) a1} in 
  mraaResultPrint'_ a1' >>
  return ()

{-# LINE 222 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


toMraaPlatform = toEnum . fromIntegral

mraaGetPlatformType :: IO ((MRAA_PLATFORM))
mraaGetPlatformType =
  mraaGetPlatformType'_ >>= \res ->
  let {res' = toMraaPlatform res} in
  return (res')

{-# LINE 227 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGetPinCount :: IO ((CUInt))
mraaGetPinCount =
  mraaGetPinCount'_ >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 230 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGetPinName :: (CInt) -> IO ((String))
mraaGetPinName a1 =
  let {a1' = fromIntegral a1} in 
  mraaGetPinName'_ a1' >>= \res ->
  peekCString res >>= \res' ->
  return (res')

{-# LINE 233 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


data I2CHandle
type I2CHandlePtr = Ptr (I2CHandle)
{-# LINE 236 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2cInit :: (CInt) -> IO ((I2CHandlePtr))
mraaI2cInit a1 =
  let {a1' = fromIntegral a1} in 
  mraaI2cInit'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 239 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2cInitRaw :: (CUInt) -> IO ((I2CHandlePtr))
mraaI2cInitRaw a1 =
  let {a1' = fromIntegral a1} in 
  mraaI2cInitRaw'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 242 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2cFrequency :: (I2CHandlePtr) -> (MRAA_I2C_MODE) -> IO ((MRAA_RESULT))
mraaI2cFrequency a1 a2 =
  let {a1' = id a1} in 
  let {a2' = (fromIntegral . fromEnum) a2} in 
  mraaI2cFrequency'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 245 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2CRead :: (I2CHandlePtr) -> (CInt) -> IO ((CInt), ([CUChar]))
mraaI2CRead a1 a3 =
  let {a1' = id a1} in 
  allocateU32 $ \a2' -> 
  let {a3' = fromIntegral a3} in 
  mraaI2CRead'_ a1' a2' a3' >>= \res ->
  let {res' = fromIntegral res} in
  peekU32  a2'>>= \a2'' -> 
  return (res', a2'')

{-# LINE 248 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2cReadByte :: (I2CHandlePtr) -> IO ((Word8))
mraaI2cReadByte a1 =
  let {a1' = id a1} in 
  mraaI2cReadByte'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 251 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2cReadByteData :: (I2CHandlePtr) -> (Word8) -> IO ((Word8))
mraaI2cReadByteData a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  mraaI2cReadByteData'_ a1' a2' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 254 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2cReadWordData :: (I2CHandlePtr) -> (Word8) -> IO ((Word16))
mraaI2cReadWordData a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  mraaI2cReadWordData'_ a1' a2' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 257 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2CReadBytesData :: (I2CHandlePtr) -> (Word8) -> (CInt) -> IO ((CInt), ([CUChar]))
mraaI2CReadBytesData a1 a2 a4 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  allocateU32 $ \a3' -> 
  let {a4' = fromIntegral a4} in 
  mraaI2CReadBytesData'_ a1' a2' a3' a4' >>= \res ->
  let {res' = fromIntegral res} in
  peekU32  a3'>>= \a3'' -> 
  return (res', a3'')

{-# LINE 260 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2cWrite :: (I2CHandlePtr) -> ([CUChar]) -> (CInt) -> IO ((MRAA_RESULT))
mraaI2cWrite a1 a2 a3 =
  let {a1' = id a1} in 
  withUCharArray a2 $ \a2' -> 
  let {a3' = fromIntegral a3} in 
  mraaI2cWrite'_ a1' a2' a3' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 263 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2cWriteByte :: (I2CHandlePtr) -> (Word8) -> IO ((MRAA_RESULT))
mraaI2cWriteByte a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  mraaI2cWriteByte'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 266 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2cWriteByteData :: (I2CHandlePtr) -> (Word8) -> (Word8) -> IO ((MRAA_RESULT))
mraaI2cWriteByteData a1 a2 a3 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = fromIntegral a3} in 
  mraaI2cWriteByteData'_ a1' a2' a3' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 269 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2cWriteWordData :: (I2CHandlePtr) -> (Word16) -> (Word8) -> IO ((MRAA_RESULT))
mraaI2cWriteWordData a1 a2 a3 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = fromIntegral a3} in 
  mraaI2cWriteWordData'_ a1' a2' a3' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 272 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2cAddress :: (I2CHandlePtr) -> (Word8) -> IO ()
mraaI2cAddress a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  mraaI2cAddress'_ a1' a2' >>
  return ()

{-# LINE 275 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaI2cStop :: (I2CHandlePtr) -> IO ((MRAA_RESULT))
mraaI2cStop a1 =
  let {a1' = id a1} in 
  mraaI2cStop'_ a1' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 278 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


data MRAA_SPI_MODE = MraaSpiMode0
                   | MraaSpiMode1
                   | MraaSpiMode2
                   | MraaSpiMode3
  deriving (Eq,Ord,Show)
instance Enum MRAA_SPI_MODE where
  succ MraaSpiMode0 = MraaSpiMode1
  succ MraaSpiMode1 = MraaSpiMode2
  succ MraaSpiMode2 = MraaSpiMode3
  succ MraaSpiMode3 = error "MRAA_SPI_MODE.succ: MraaSpiMode3 has no successor"

  pred MraaSpiMode1 = MraaSpiMode0
  pred MraaSpiMode2 = MraaSpiMode1
  pred MraaSpiMode3 = MraaSpiMode2
  pred MraaSpiMode0 = error "MRAA_SPI_MODE.pred: MraaSpiMode0 has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from MraaSpiMode3

  fromEnum MraaSpiMode0 = 0
  fromEnum MraaSpiMode1 = 1
  fromEnum MraaSpiMode2 = 2
  fromEnum MraaSpiMode3 = 3

  toEnum 0 = MraaSpiMode0
  toEnum 1 = MraaSpiMode1
  toEnum 2 = MraaSpiMode2
  toEnum 3 = MraaSpiMode3
  toEnum unmatched = error ("MRAA_SPI_MODE.toEnum: Cannot match " ++ show unmatched)

{-# LINE 285 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


data SPIHandle
type SPIHandlePtr = Ptr (SPIHandle)
{-# LINE 288 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaSpiInit :: (CInt) -> IO ((SPIHandlePtr))
mraaSpiInit a1 =
  let {a1' = fromIntegral a1} in 
  mraaSpiInit'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 291 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaSpiInitRaw :: (CUInt) -> (CUInt) -> IO ((SPIHandlePtr))
mraaSpiInitRaw a1 a2 =
  let {a1' = fromIntegral a1} in 
  let {a2' = fromIntegral a2} in 
  mraaSpiInitRaw'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 294 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaSpiMode :: (SPIHandlePtr) -> (MRAA_SPI_MODE) -> IO ((MRAA_RESULT))
mraaSpiMode a1 a2 =
  let {a1' = id a1} in 
  let {a2' = (fromIntegral . fromEnum) a2} in 
  mraaSpiMode'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 297 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaSpiFrequency :: (SPIHandlePtr) -> (CInt) -> IO ((MRAA_RESULT))
mraaSpiFrequency a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  mraaSpiFrequency'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 300 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaSpiWrite :: (SPIHandlePtr) -> (Word8) -> IO ((CInt))
mraaSpiWrite a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  mraaSpiWrite'_ a1' a2' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 303 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaSpiWriteWord :: (SPIHandlePtr) -> (Word16) -> IO ((CInt))
mraaSpiWriteWord a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  mraaSpiWriteWord'_ a1' a2' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 306 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


-- Not freeing returned array
mraaSpiWriteBuf :: (SPIHandlePtr) -> ([CUChar]) -> (CInt) -> IO (([CUChar]))
mraaSpiWriteBuf a1 a2 a3 =
  let {a1' = id a1} in 
  withUCharArray a2 $ \a2' -> 
  let {a3' = fromIntegral a3} in 
  mraaSpiWriteBuf'_ a1' a2' a3' >>= \res ->
  peekArray (fromIntegral a3) res >>= \res' ->
  return (res')

{-# LINE 310 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


-- Not freeing returned array
mraaSpiWriteBufWord :: (SPIHandlePtr) -> ([CUShort]) -> (CInt) -> IO (([CUShort]))
mraaSpiWriteBufWord a1 a2 a3 =
  let {a1' = id a1} in 
  withUShortArray a2 $ \a2' -> 
  let {a3' = fromIntegral a3} in 
  mraaSpiWriteBufWord'_ a1' a2' a3' >>= \res ->
  peekArray (2 * fromIntegral a3) res >>= \res' ->
  return (res')

{-# LINE 314 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaSpiTransferBuf :: (SPIHandlePtr) -> ([CUChar]) -> (CInt) -> IO ((MRAA_RESULT), ([CUChar]))
mraaSpiTransferBuf a1 a2 a4 =
  let {a1' = id a1} in 
  withUCharArray a2 $ \a2' -> 
  allocateU32 $ \a3' -> 
  let {a4' = fromIntegral a4} in 
  mraaSpiTransferBuf'_ a1' a2' a3' a4' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  peekArray (fromIntegral a4)  a3'>>= \a3'' -> 
  return (res', a3'')

{-# LINE 317 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaSpiTransferBufWord :: (SPIHandlePtr) -> ([CUShort]) -> (CInt) -> IO ((MRAA_RESULT), ([CUShort]))
mraaSpiTransferBufWord a1 a2 a4 =
  let {a1' = id a1} in 
  withUShortArray a2 $ \a2' -> 
  allocateU32s $ \a3' -> 
  let {a4' = fromIntegral a4} in 
  mraaSpiTransferBufWord'_ a1' a2' a3' a4' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  peekArray (fromIntegral a4)  a3'>>= \a3'' -> 
  return (res', a3'')

{-# LINE 320 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaSpiLsbmode :: (SPIHandlePtr) -> (Bool) -> IO ((MRAA_RESULT))
mraaSpiLsbmode a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromBool a2} in 
  mraaSpiLsbmode'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 323 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaSpiBitPerWord :: (SPIHandlePtr) -> (CUInt) -> IO ((MRAA_RESULT))
mraaSpiBitPerWord a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  mraaSpiBitPerWord'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 326 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaSpiStop :: (SPIHandlePtr) -> IO ((MRAA_RESULT))
mraaSpiStop a1 =
  let {a1' = id a1} in 
  mraaSpiStop'_ a1' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 329 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


data MRAA_GPIO_MODE = MraaGpioStrong
                    | MraaGpioPullup
                    | MraaGpioPulldown
                    | MraaGpioHiz
  deriving (Eq,Ord,Show)
instance Enum MRAA_GPIO_MODE where
  succ MraaGpioStrong = MraaGpioPullup
  succ MraaGpioPullup = MraaGpioPulldown
  succ MraaGpioPulldown = MraaGpioHiz
  succ MraaGpioHiz = error "MRAA_GPIO_MODE.succ: MraaGpioHiz has no successor"

  pred MraaGpioPullup = MraaGpioStrong
  pred MraaGpioPulldown = MraaGpioPullup
  pred MraaGpioHiz = MraaGpioPulldown
  pred MraaGpioStrong = error "MRAA_GPIO_MODE.pred: MraaGpioStrong has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from MraaGpioHiz

  fromEnum MraaGpioStrong = 0
  fromEnum MraaGpioPullup = 1
  fromEnum MraaGpioPulldown = 2
  fromEnum MraaGpioHiz = 3

  toEnum 0 = MraaGpioStrong
  toEnum 1 = MraaGpioPullup
  toEnum 2 = MraaGpioPulldown
  toEnum 3 = MraaGpioHiz
  toEnum unmatched = error ("MRAA_GPIO_MODE.toEnum: Cannot match " ++ show unmatched)

{-# LINE 336 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


data MRAA_GPIO_DIR = MraaGpioOut
                   | MraaGpioIn
                   | MraaGpioOutHigh
                   | MraaGpioOutLow
  deriving (Eq,Ord,Show)
instance Enum MRAA_GPIO_DIR where
  succ MraaGpioOut = MraaGpioIn
  succ MraaGpioIn = MraaGpioOutHigh
  succ MraaGpioOutHigh = MraaGpioOutLow
  succ MraaGpioOutLow = error "MRAA_GPIO_DIR.succ: MraaGpioOutLow has no successor"

  pred MraaGpioIn = MraaGpioOut
  pred MraaGpioOutHigh = MraaGpioIn
  pred MraaGpioOutLow = MraaGpioOutHigh
  pred MraaGpioOut = error "MRAA_GPIO_DIR.pred: MraaGpioOut has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from MraaGpioOutLow

  fromEnum MraaGpioOut = 0
  fromEnum MraaGpioIn = 1
  fromEnum MraaGpioOutHigh = 2
  fromEnum MraaGpioOutLow = 3

  toEnum 0 = MraaGpioOut
  toEnum 1 = MraaGpioIn
  toEnum 2 = MraaGpioOutHigh
  toEnum 3 = MraaGpioOutLow
  toEnum unmatched = error ("MRAA_GPIO_DIR.toEnum: Cannot match " ++ show unmatched)

{-# LINE 343 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}



data MRAA_GPIO_EDGE = MraaGpioEdgeNone
                    | MraaGpioEdgeBoth
                    | MraaGpioEdgeRising
                    | MraaGpioEdgeFalling
  deriving (Eq,Ord,Show)
instance Enum MRAA_GPIO_EDGE where
  succ MraaGpioEdgeNone = MraaGpioEdgeBoth
  succ MraaGpioEdgeBoth = MraaGpioEdgeRising
  succ MraaGpioEdgeRising = MraaGpioEdgeFalling
  succ MraaGpioEdgeFalling = error "MRAA_GPIO_EDGE.succ: MraaGpioEdgeFalling has no successor"

  pred MraaGpioEdgeBoth = MraaGpioEdgeNone
  pred MraaGpioEdgeRising = MraaGpioEdgeBoth
  pred MraaGpioEdgeFalling = MraaGpioEdgeRising
  pred MraaGpioEdgeNone = error "MRAA_GPIO_EDGE.pred: MraaGpioEdgeNone has no predecessor"

  enumFromTo from to = go from
    where
      end = fromEnum to
      go v = case compare (fromEnum v) end of
                 LT -> v : go (succ v)
                 EQ -> [v]
                 GT -> []

  enumFrom from = enumFromTo from MraaGpioEdgeFalling

  fromEnum MraaGpioEdgeNone = 0
  fromEnum MraaGpioEdgeBoth = 1
  fromEnum MraaGpioEdgeRising = 2
  fromEnum MraaGpioEdgeFalling = 3

  toEnum 0 = MraaGpioEdgeNone
  toEnum 1 = MraaGpioEdgeBoth
  toEnum 2 = MraaGpioEdgeRising
  toEnum 3 = MraaGpioEdgeFalling
  toEnum unmatched = error ("MRAA_GPIO_EDGE.toEnum: Cannot match " ++ show unmatched)

{-# LINE 351 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


data GPIOHandle
type GPIOHandlePtr = Ptr (GPIOHandle)
{-# LINE 354 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGpioInit :: (CInt) -> IO ((GPIOHandlePtr))
mraaGpioInit a1 =
  let {a1' = fromIntegral a1} in 
  mraaGpioInit'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 357 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGpioInitRaw :: (CInt) -> IO ((GPIOHandlePtr))
mraaGpioInitRaw a1 =
  let {a1' = fromIntegral a1} in 
  mraaGpioInitRaw'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 360 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGpioEdgeMode :: (GPIOHandlePtr) -> (MRAA_GPIO_EDGE) -> IO ((MRAA_RESULT))
mraaGpioEdgeMode a1 a2 =
  let {a1' = id a1} in 
  let {a2' = (fromIntegral . fromEnum) a2} in 
  mraaGpioEdgeMode'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 363 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


{-
 mraa_result_t mraa_gpio_isr(mraa_gpio_context dev, gpio_edge_t edge, void (*fptr)(void*), void* args);
 mraa_result_t mraa_gpio_isr_exit(mraa_gpio_context dev);
-}

mraaGpioMode :: (GPIOHandlePtr) -> (MRAA_GPIO_MODE) -> IO ((MRAA_RESULT))
mraaGpioMode a1 a2 =
  let {a1' = id a1} in 
  let {a2' = (fromIntegral . fromEnum) a2} in 
  mraaGpioMode'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 371 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGpioDir :: (GPIOHandlePtr) -> (MRAA_GPIO_DIR) -> IO ((MRAA_RESULT))
mraaGpioDir a1 a2 =
  let {a1' = id a1} in 
  let {a2' = (fromIntegral . fromEnum) a2} in 
  mraaGpioDir'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 374 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGpioClose :: (GPIOHandlePtr) -> IO ((MRAA_RESULT))
mraaGpioClose a1 =
  let {a1' = id a1} in 
  mraaGpioClose'_ a1' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 377 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGpioRead :: (GPIOHandlePtr) -> IO ((CInt))
mraaGpioRead a1 =
  let {a1' = id a1} in 
  mraaGpioRead'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 380 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGpioWrite :: (GPIOHandlePtr) -> (CInt) -> IO ((MRAA_RESULT))
mraaGpioWrite a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  mraaGpioWrite'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 383 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGpioOwner :: (GPIOHandlePtr) -> (Bool) -> IO ((MRAA_RESULT))
mraaGpioOwner a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromBool a2} in 
  mraaGpioOwner'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 386 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGpioUseMmapped :: (GPIOHandlePtr) -> (Bool) -> IO ((MRAA_RESULT))
mraaGpioUseMmapped a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromBool a2} in 
  mraaGpioUseMmapped'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 389 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGpioGetPin :: (GPIOHandlePtr) -> IO ((CInt))
mraaGpioGetPin a1 =
  let {a1' = id a1} in 
  mraaGpioGetPin'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 392 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaGpioGetPinRaw :: (GPIOHandlePtr) -> IO ((CInt))
mraaGpioGetPinRaw a1 =
  let {a1' = id a1} in 
  mraaGpioGetPinRaw'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 395 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


data UARTHandle
type UARTHandlePtr = Ptr (UARTHandle)
{-# LINE 398 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaUartInit :: (Int) -> IO ((UARTHandlePtr))
mraaUartInit a1 =
  let {a1' = fromIntegral a1} in 
  mraaUartInit'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 401 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaUartInitRaw :: ([CChar]) -> IO ((UARTHandlePtr))
mraaUartInitRaw a1 =
  withCharArray a1 $ \a1' -> 
  mraaUartInitRaw'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')

{-# LINE 404 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaUartFlush :: (UARTHandlePtr) -> IO ((MRAA_RESULT))
mraaUartFlush a1 =
  let {a1' = id a1} in 
  mraaUartFlush'_ a1' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 407 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaUartSetBaudrate :: (UARTHandlePtr) -> (CUInt) -> IO ((MRAA_RESULT))
mraaUartSetBaudrate a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  mraaUartSetBaudrate'_ a1' a2' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 410 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaUartSetMode :: (UARTHandlePtr) -> (CInt) -> (MRAA_UART_PARITY) -> (CInt) -> IO ((MRAA_RESULT))
mraaUartSetMode a1 a2 a3 a4 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = (fromIntegral . fromEnum) a3} in 
  let {a4' = fromIntegral a4} in 
  mraaUartSetMode'_ a1' a2' a3' a4' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 413 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaUartSetFlowcontrol :: (UARTHandlePtr) -> (Bool) -> (Bool) -> IO ((MRAA_RESULT))
mraaUartSetFlowcontrol a1 a2 a3 =
  let {a1' = id a1} in 
  let {a2' = fromBool a2} in 
  let {a3' = fromBool a3} in 
  mraaUartSetFlowcontrol'_ a1' a2' a3' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 416 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaUartSetTimeout :: (UARTHandlePtr) -> (CInt) -> (CInt) -> (CInt) -> IO ((MRAA_RESULT))
mraaUartSetTimeout a1 a2 a3 a4 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  let {a3' = fromIntegral a3} in 
  let {a4' = fromIntegral a4} in 
  mraaUartSetTimeout'_ a1' a2' a3' a4' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 419 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaUartGetDevPath :: (UARTHandlePtr) -> IO ((String))
mraaUartGetDevPath a1 =
  let {a1' = id a1} in 
  mraaUartGetDevPath'_ a1' >>= \res ->
  peekCString res >>= \res' ->
  return (res')

{-# LINE 422 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaUartStop :: (UARTHandlePtr) -> IO ((MRAA_RESULT))
mraaUartStop a1 =
  let {a1' = id a1} in 
  mraaUartStop'_ a1' >>= \res ->
  let {res' = (toEnum . fromIntegral) res} in
  return (res')

{-# LINE 425 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaUartRead :: (UARTHandlePtr) -> (CUInt) -> IO ((CInt), ([CChar]))
mraaUartRead a1 a3 =
  let {a1' = id a1} in 
  allocate32 $ \a2' -> 
  let {a3' = fromIntegral a3} in 
  mraaUartRead'_ a1' a2' a3' >>= \res ->
  let {res' = fromIntegral res} in
  peekArray (fromIntegral a3)  a2'>>= \a2'' -> 
  return (res', a2'')

{-# LINE 428 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaUartWrite :: (UARTHandlePtr) -> ([CChar]) -> (CUInt) -> IO ((CInt))
mraaUartWrite a1 a2 a3 =
  let {a1' = id a1} in 
  withCharArray a2 $ \a2' -> 
  let {a3' = fromIntegral a3} in 
  mraaUartWrite'_ a1' a2' a3' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')

{-# LINE 431 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}


mraaUartDataAvailable :: (UARTHandlePtr) -> (CUInt) -> IO ((Bool))
mraaUartDataAvailable a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  mraaUartDataAvailable'_ a1' a2' >>= \res ->
  let {res' = toBool res} in
  return (res')

{-# LINE 434 "src/System/Hardware/Mraa/chs/Mraa.chs" #-}



foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_init"
  mraaInit'_ :: (IO CInt)

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_deinit"
  mraaDeinit'_ :: (IO ())

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_pin_mode_test"
  mraaPinModeTest'_ :: (CInt -> (CInt -> (IO CUInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_adc_raw_bits"
  mraaAdcRawBits'_ :: (IO CUInt)

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_adc_supported_bits"
  mraaAdcSupportedBits'_ :: (IO CUInt)

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_set_log_level"
  mraaSetLogLevel'_ :: (CInt -> (IO CInt))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_get_platform_name"
  mraaGetPlatformName'_ :: (IO (Ptr CChar))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_set_priority"
  mraaSetPriority'_ :: (CUInt -> (IO CInt))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_get_version"
  mraaGetVersion'_ :: (IO (Ptr CChar))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_result_print"
  mraaResultPrint'_ :: (CInt -> (IO ()))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_get_platform_type"
  mraaGetPlatformType'_ :: (IO CInt)

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_get_pin_count"
  mraaGetPinCount'_ :: (IO CUInt)

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_get_pin_name"
  mraaGetPinName'_ :: (CInt -> (IO (Ptr CChar)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_init"
  mraaI2cInit'_ :: (CInt -> (IO (I2CHandlePtr)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_init_raw"
  mraaI2cInitRaw'_ :: (CUInt -> (IO (I2CHandlePtr)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_frequency"
  mraaI2cFrequency'_ :: ((I2CHandlePtr) -> (CInt -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_read"
  mraaI2CRead'_ :: ((I2CHandlePtr) -> ((Ptr CUChar) -> (CInt -> (IO CInt))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_read_byte"
  mraaI2cReadByte'_ :: ((I2CHandlePtr) -> (IO CUChar))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_read_byte_data"
  mraaI2cReadByteData'_ :: ((I2CHandlePtr) -> (CUChar -> (IO CUChar)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_read_word_data"
  mraaI2cReadWordData'_ :: ((I2CHandlePtr) -> (CUChar -> (IO CUShort)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_read_bytes_data"
  mraaI2CReadBytesData'_ :: ((I2CHandlePtr) -> (CUChar -> ((Ptr CUChar) -> (CInt -> (IO CInt)))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_write"
  mraaI2cWrite'_ :: ((I2CHandlePtr) -> ((Ptr CUChar) -> (CInt -> (IO CInt))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_write_byte"
  mraaI2cWriteByte'_ :: ((I2CHandlePtr) -> (CUChar -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_write_byte_data"
  mraaI2cWriteByteData'_ :: ((I2CHandlePtr) -> (CUChar -> (CUChar -> (IO CInt))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_write_word_data"
  mraaI2cWriteWordData'_ :: ((I2CHandlePtr) -> (CUShort -> (CUChar -> (IO CInt))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_address"
  mraaI2cAddress'_ :: ((I2CHandlePtr) -> (CUChar -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_i2c_stop"
  mraaI2cStop'_ :: ((I2CHandlePtr) -> (IO CInt))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_spi_init"
  mraaSpiInit'_ :: (CInt -> (IO (SPIHandlePtr)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_spi_init_raw"
  mraaSpiInitRaw'_ :: (CUInt -> (CUInt -> (IO (SPIHandlePtr))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_spi_mode"
  mraaSpiMode'_ :: ((SPIHandlePtr) -> (CInt -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_spi_frequency"
  mraaSpiFrequency'_ :: ((SPIHandlePtr) -> (CInt -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_spi_write"
  mraaSpiWrite'_ :: ((SPIHandlePtr) -> (CUChar -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_spi_write_word"
  mraaSpiWriteWord'_ :: ((SPIHandlePtr) -> (CUShort -> (IO CUShort)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_spi_write_buf"
  mraaSpiWriteBuf'_ :: ((SPIHandlePtr) -> ((Ptr CUChar) -> (CInt -> (IO (Ptr CUChar)))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_spi_write_buf_word"
  mraaSpiWriteBufWord'_ :: ((SPIHandlePtr) -> ((Ptr CUShort) -> (CInt -> (IO (Ptr CUShort)))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_spi_transfer_buf"
  mraaSpiTransferBuf'_ :: ((SPIHandlePtr) -> ((Ptr CUChar) -> ((Ptr CUChar) -> (CInt -> (IO CInt)))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_spi_transfer_buf_word"
  mraaSpiTransferBufWord'_ :: ((SPIHandlePtr) -> ((Ptr CUShort) -> ((Ptr CUShort) -> (CInt -> (IO CInt)))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_spi_lsbmode"
  mraaSpiLsbmode'_ :: ((SPIHandlePtr) -> (CUInt -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_spi_bit_per_word"
  mraaSpiBitPerWord'_ :: ((SPIHandlePtr) -> (CUInt -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_spi_stop"
  mraaSpiStop'_ :: ((SPIHandlePtr) -> (IO CInt))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_gpio_init"
  mraaGpioInit'_ :: (CInt -> (IO (GPIOHandlePtr)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_gpio_init_raw"
  mraaGpioInitRaw'_ :: (CInt -> (IO (GPIOHandlePtr)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_gpio_edge_mode"
  mraaGpioEdgeMode'_ :: ((GPIOHandlePtr) -> (CInt -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_gpio_mode"
  mraaGpioMode'_ :: ((GPIOHandlePtr) -> (CInt -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_gpio_dir"
  mraaGpioDir'_ :: ((GPIOHandlePtr) -> (CInt -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_gpio_close"
  mraaGpioClose'_ :: ((GPIOHandlePtr) -> (IO CInt))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_gpio_read"
  mraaGpioRead'_ :: ((GPIOHandlePtr) -> (IO CInt))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_gpio_write"
  mraaGpioWrite'_ :: ((GPIOHandlePtr) -> (CInt -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_gpio_owner"
  mraaGpioOwner'_ :: ((GPIOHandlePtr) -> (CUInt -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_gpio_use_mmaped"
  mraaGpioUseMmapped'_ :: ((GPIOHandlePtr) -> (CUInt -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_gpio_get_pin"
  mraaGpioGetPin'_ :: ((GPIOHandlePtr) -> (IO CInt))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_gpio_get_pin_raw"
  mraaGpioGetPinRaw'_ :: ((GPIOHandlePtr) -> (IO CInt))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_uart_init"
  mraaUartInit'_ :: (CInt -> (IO (UARTHandlePtr)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_uart_init_raw"
  mraaUartInitRaw'_ :: ((Ptr CChar) -> (IO (UARTHandlePtr)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_uart_flush"
  mraaUartFlush'_ :: ((UARTHandlePtr) -> (IO CInt))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_uart_set_baudrate"
  mraaUartSetBaudrate'_ :: ((UARTHandlePtr) -> (CUInt -> (IO CInt)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_uart_set_mode"
  mraaUartSetMode'_ :: ((UARTHandlePtr) -> (CInt -> (CInt -> (CInt -> (IO CInt)))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_uart_set_flowcontrol"
  mraaUartSetFlowcontrol'_ :: ((UARTHandlePtr) -> (CUInt -> (CUInt -> (IO CInt))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_uart_set_timeout"
  mraaUartSetTimeout'_ :: ((UARTHandlePtr) -> (CInt -> (CInt -> (CInt -> (IO CInt)))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_uart_get_dev_path"
  mraaUartGetDevPath'_ :: ((UARTHandlePtr) -> (IO (Ptr CChar)))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_uart_stop"
  mraaUartStop'_ :: ((UARTHandlePtr) -> (IO CInt))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_uart_read"
  mraaUartRead'_ :: ((UARTHandlePtr) -> ((Ptr CChar) -> (CUInt -> (IO CInt))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_uart_write"
  mraaUartWrite'_ :: ((UARTHandlePtr) -> ((Ptr CChar) -> (CUInt -> (IO CInt))))

foreign import ccall unsafe "src/System/Hardware/Mraa/Mraa.chs.h mraa_uart_data_available"
  mraaUartDataAvailable'_ :: ((UARTHandlePtr) -> (CUInt -> (IO CUInt)))
